

// IMPORTANT - this mirrors the constant with the same name in ShapeGerstnerBatchedCompute.cs, both must be updated together!
#define BATCH_SIZE 32

#define PI 3.141593


// // TODO: get this to match OceanLodDada.hlsl
// #define CREST_OCEAN_DEPTH_BASELINE 1000.

// #include "../../OceanLODData.hlsl"

// TODO: factor these to share with OceanLODData
#define LOD_DATA(LODNUM) \
	uniform Texture2D<float4> _LD_Sampler_AnimatedWaves_##LODNUM; \
	uniform Texture2D<float4> _LD_Sampler_SeaFloorDepth_##LODNUM; \
	uniform Texture2D<float4> _LD_Sampler_Foam_##LODNUM; \
	uniform Texture2D<float4> _LD_Sampler_Flow_##LODNUM; \
	uniform Texture2D<float4> _LD_Sampler_DynamicWaves_##LODNUM; \
	uniform Texture2D<float4> _LD_Sampler_Shadow_##LODNUM; \
	uniform float4 _LD_Params_##LODNUM; \
	uniform float3 _LD_Pos_Scale_##LODNUM;

// Create two sets of LOD data, which have overloaded meaning depending on use:
// * the ocean surface geometry always lerps from a more detailed LOD (0) to a less detailed LOD (1)
// * simulations (persistent lod data) read last frame's data from slot 0, and any current frame data from slot 1
// * any other use that does not fall into the previous categories can use either slot and generally use slot 0
LOD_DATA( 0 )
LOD_DATA( 1 )

// Bias ocean floor depth so that default (0) values in texture are not interpreted as shallow and generating foam everywhere
#define CREST_OCEAN_DEPTH_BASELINE 1000.

// Conversions for world space from/to UV space
float2 LD_WorldToUV(in float2 i_samplePos, in float2 i_centerPos, in float i_res, in float i_texelSize)
{
	return (i_samplePos - i_centerPos) / (i_texelSize * i_res) + 0.5;
}
float2 LD_0_WorldToUV(in float2 i_samplePos) { return LD_WorldToUV(i_samplePos, _LD_Pos_Scale_0.xy, _LD_Params_0.y, _LD_Params_0.x); }
float2 LD_1_WorldToUV(in float2 i_samplePos) { return LD_WorldToUV(i_samplePos, _LD_Pos_Scale_1.xy, _LD_Params_1.y, _LD_Params_1.x); }

float2 LD_UVToWorld(in float2 i_uv, in float2 i_centerPos, in float i_res, in float i_texelSize)
{
	return i_texelSize * i_res * (i_uv - 0.5) + i_centerPos;
}
float2 LD_0_UVToWorld(in float2 i_uv) { return LD_UVToWorld(i_uv, _LD_Pos_Scale_0.xy, _LD_Params_0.y, _LD_Params_0.x); }
float2 LD_1_UVToWorld(in float2 i_uv) { return LD_UVToWorld(i_uv, _LD_Pos_Scale_1.xy, _LD_Params_1.y, _LD_Params_1.x); }


// END SHARED



uint _NumInBatch;
half _AttenuationInShallows;
uint _NumWaveVecs;

half4 _TwoPiOverWavelengths[BATCH_SIZE / 4];
half4 _Amplitudes[BATCH_SIZE / 4];
half4 _WaveDirX[BATCH_SIZE / 4];
half4 _WaveDirZ[BATCH_SIZE / 4];
half4 _Phases[BATCH_SIZE / 4];
half4 _ChopAmps[BATCH_SIZE / 4];

// Texture2D<float4> _LD_Sample_SeaFloorDepth0;
RWTexture2D<float4> WaveBuffer;

#pragma kernel AnimWavesGerstnerBatchCompute
[numthreads(8,8,1)]
void AnimWavesGerstnerBatchCompute (uint3 id : SV_DispatchThreadID)
{

    // TODO: Calculate UVs to sample shader :)

    const half4 oneMinusAttenuation = (half4)1.0 - (half4)_AttenuationInShallows;


    half2 textureRes = half2(_LD_Params_0.y, _LD_Params_0.y);
    half2 uv = half2(id.xy) / textureRes + 0.5 / textureRes;

    float2 worldXZ = LD_0_UVToWorld(uv);

    SamplerState MeshTextureSampler
    {
        Filter = MIN_MAG_MIP_LINEAR;
        AddressU = Wrap;
        AddressV = Wrap;
    };



    // sample ocean depth (this render target should 1:1 match depth texture, so UVs are trivial)
    const half depth = CREST_OCEAN_DEPTH_BASELINE - _LD_Sampler_SeaFloorDepth_0[id.xy].x;
    half3 result = (half3)0.0;

    // gerstner computation is vectorized - processes 4 wave components at once
    for (uint vi = 0; vi < _NumWaveVecs; vi++)
    {
        // attenuate waves based on ocean depth. if depth is greater than 0.5*wavelength, water is considered Deep and wave is
        // unaffected. if depth is less than this, wave velocity decreases. waves will then bunch up and grow in amplitude and
        // eventually break. i model "Deep" water, but then simply ramp down waves in non-deep water with a linear multiplier.
        // http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html
        // http://hyperphysics.phy-astr.gsu.edu/hbase/watwav.html#c1
        //half depth_wt = saturate(depth / (0.5 * _MinWavelength)); // slightly different result - do per wavelength for now
        // The below is a few things collapsed together.
        half4 depth_wt = saturate(depth * _TwoPiOverWavelengths[vi] / PI);
        // keep some proportion of amplitude so that there is some waves remaining
        half4 wt = _AttenuationInShallows * depth_wt + oneMinusAttenuation;

        // direction
        half4 Dx = _WaveDirX[vi];
        half4 Dz = _WaveDirZ[vi];
        // wave number
        half4 k = _TwoPiOverWavelengths[vi];
        // spatial location
        half4 x = Dx * worldXZ.x + Dz * worldXZ.y;
        half4 angle = k * x + _Phases[vi];

        // dx and dz could be baked into _ChopAmps
        half4 disp = _ChopAmps[vi] * sin(angle);
        half4 resultx = disp * Dx;
        half4 resultz = disp * Dz;

        half4 resulty = _Amplitudes[vi] * cos(angle);

        // sum the vector results
        result.x += dot(resultx, wt);
        result.y += dot(resulty, wt);
        result.z += dot(resultz, wt);
    }

    WaveBuffer[id.xy] = half4(result, 0.0);
}
